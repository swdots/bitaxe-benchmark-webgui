<!doctype html>
<html lang="en" data-theme="dark">
<head>
  <meta charset="utf-8" />
  <title>Benchmark run details</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #050711;
      --fg: #f9fafb;
      --muted: #94a3b8;
      --accent: #22c55e;
      --danger: #ef4444;
      --card: #0b1120;
      --border: #1f2937;
      --table-stripe: #020617;
    }
    [data-theme="light"] {
      --bg: #f9fafb;
      --fg: #020617;
      --muted: #6b7280;
      --accent: #16a34a;
      --danger: #b91c1c;
      --card: #ffffff;
      --border: #e5e7eb;
      --table-stripe: #f3f4f6;
    }
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text", sans-serif;
      background: radial-gradient(circle at top left, #111827 0, var(--bg) 40%);
      color: var(--fg);
    }
    a {
      color: var(--accent);
      text-decoration: none;
    }
    a:hover {
      text-decoration: underline;
    }
    .page {
      max-width: 1200px;
      margin: 0 auto;
      padding: 1rem 1rem 3rem;
    }
    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
      margin-bottom: 1rem;
    }
    header h1 {
      font-size: 1.4rem;
      margin: 0;
    }
    .sub {
      font-size: 0.85rem;
      color: var(--muted);
    }
    .card {
      background: color-mix(in srgb, var(--card) 92%, transparent);
      border-radius: 16px;
      padding: 1rem 1.2rem;
      border: 1px solid var(--border);
      box-shadow: 0 18px 45px rgba(15, 23, 42, 0.45);
      margin-bottom: 1rem;
    }
    .card-title {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.75rem;
    }
    .card-title h2 {
      font-size: 1rem;
      margin: 0;
    }
    .pill {
      font-size: 0.75rem;
      border-radius: 999px;
      padding: 0.2rem 0.6rem;
      border: 1px solid var(--border);
      color: var(--muted);
    }
    .row {
      display: flex;
      gap: 0.75rem;
      flex-wrap: wrap;
      align-items: center;
      margin-bottom: 0.4rem;
    }
    .row > * {
      flex: 1;
    }
    .row > .shrink {
      flex: 0 0 auto;
    }
    .btn {
      padding: 0.4rem 0.8rem;
      border-radius: 999px;
      border: 1px solid transparent;
      font-size: 0.85rem;
      cursor: pointer;
      background: var(--accent);
      color: white;
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
    }
    .btn.secondary {
      background: transparent;
      border-color: var(--border);
      color: var(--fg);
    }
    .btn.danger {
      background: var(--danger);
      color: white;
    }
    .btn:disabled {
      opacity: 0.5;
      cursor: default;
    }
    .muted {
      color: var(--muted);
    }
    .mono {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.8rem;
    }
    th,
    td {
      padding: 0.35rem 0.4rem;
      text-align: left;
      border-bottom: 1px solid var(--border);
    }
    th {
      font-weight: 500;
      color: var(--muted);
      white-space: nowrap;
    }
    tbody tr:nth-child(odd) {
      background: color-mix(in srgb, var(--table-stripe) 50%, transparent);
    }

    .best-hashrate {
      border: 1px solid #fb923c;
      box-shadow: 0 0 0 1px rgba(251, 146, 60, 0.5);
      background: rgba(251, 146, 60, 0.12);
    }
    .best-efficiency {
      border: 1px solid #22c55e;
      box-shadow: 0 0 0 1px rgba(34, 197, 94, 0.5);
      background: rgba(34, 197, 94, 0.12);
    }

    .charts-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: 1rem;
    }
	.heatmaps-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 1rem;
      margin-top: 0.75rem;
    }
	/* When the section has the "heatmaps-large" class, stack vertically */
	#heatmapSection.heatmaps-large .heatmaps-grid {
	  grid-template-columns: minmax(0, 1fr); /* single column */
	}

	/* Optional: allow horizontal scroll if a single heatmap is very wide */
	.heatmap-card {
	  overflow-x: auto;
	}

    .heatmap-card h3 {
      font-size: 0.9rem;
      margin: 0 0 0.35rem;
    }
    .heatmap-grid {
      border-collapse: collapse;
      width: 100%;
      font-size: 0.7rem;
    }
    .heatmap-grid th,
    .heatmap-grid td {
      border: 1px solid var(--border);
      padding: 0.15rem 0.25rem;
      text-align: center;
    }
    .heatmap-grid th {
      background: var(--table-stripe);
    }
    .heatmap-cell-value {
      opacity: 0.9;
    }
	.heatmap-grid td.heatmap-failed {
	  border: 1px solid rgba(0,0,0,0.2);
	}

	[data-theme="dark"] .heatmap-grid td.heatmap-failed {
	  border-color: rgba(255,255,255,0.25);
	}

	.heatmap-grid td.heatmap-skipped {
	  opacity: 0.6;
	}


    
	/* Stability highlighting (outlines only; keep heatmap colors) */
	.heatmap-grid td.heatmap-stable {
	  box-shadow: inset 0 0 0 2px rgba(236, 72, 153, 0.85); /* pink outline */
	}
	.heatmap-grid td.heatmap-best-stable {
	  box-shadow: inset 0 0 0 3px rgba(255, 255, 255, 0.90); /* white outline */
	  font-weight: 600;
	}

canvas {
      width: 100%;
      max-width: 100%;
    }

    #timelineWrapper {
      margin-bottom: 1rem;
    }
    #timelineWrapper canvas {
      width: 100%;
      max-width: 100%;
    }

    details.raw-json summary {
      cursor: pointer;
      font-size: 0.85rem;
      color: var(--muted);
      margin-bottom: 0.3rem;
    }

    @media (max-width: 768px) {
      header {
        flex-direction: column;
        align-items: flex-start;
      }
      .card {
        padding: 0.9rem 0.8rem;
      }
    }

    /* Form controls (match index.html style) */
    input[type="text"],
    input[type="number"],
    select,
    textarea {
      width: 100%;
      padding: 0.4rem 0.5rem;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: color-mix(in srgb, var(--bg) 85%, var(--card) 15%);
      color: var(--fg);
      font-size: 0.85rem;
      box-sizing: border-box;
    }

    textarea {
      resize: vertical;
    }

    /* Specifically make the notes area larger by default */
    #notesTextarea {
      min-height: 120px;
    }

    /* Focus state */
    input:focus,
    select:focus,
    textarea:focus {
      outline: 1px solid var(--accent);
      border-color: var(--accent);
    }
  </style>
</head>
<body>
  <div class="page">
    <header>
      <div>
        <h1>Benchmark run details</h1>
        <div class="sub">
          Run ID: <span class="mono" id="runIdLabel">–</span>
        </div>
      </div>
      <div class="row" style="justify-content:flex-end;margin-bottom:0;">
        <a href="index.html" class="btn secondary shrink">← Back to benchmarks</a>
        <button class="btn secondary shrink" id="themeToggle">Toggle theme</button>
      </div>
    </header>

    <!-- Overview -->
    <section class="card">
      <div class="card-title">
        <h2>Overview</h2>
        <span class="pill" id="statusPill">Loading…</span>
      </div>
      <div id="overviewBody" class="muted" style="font-size:0.9rem;margin-bottom:0.5rem;">
        Fetching run data…
      </div>
      <div class="row" style="margin-top:0.25rem;flex-wrap:wrap;gap:0.5rem;">
        <div style="flex:1;min-width:180px;">
          <div id="bestHashrateChip" class="muted" style="font-size:0.8rem;"></div>
        </div>
        <div style="flex:1;min-width:180px;">
          <div id="bestEfficiencyChip" class="muted" style="font-size:0.8rem;"></div>
        </div>
        <div class="shrink" style="text-align:right;">
          <a id="csvLink" class="btn secondary shrink" href="#">Download CSV</a>
        </div>
      </div>
    </section>

    <!-- Notes -->
    <section class="card">
      <div class="card-title">
        <h2>Run notes</h2>
        <span class="pill">Add comments like “after repaste”, “stock fan”, etc.</span>
      </div>
      <textarea id="notesTextarea" placeholder="No notes yet. Add context about this run…"></textarea>
      <div class="row" style="justify-content:flex-end;margin-top:0.5rem;">
        <button class="btn shrink" id="saveNotesBtn" style="flex:0 0 auto;">Save notes</button>
      </div>
      <div id="notesStatus" class="muted" style="font-size:0.8rem;margin-top:0.35rem;"></div>
    </section>

    <!-- Results table -->
    <section class="card">
      <div class="card-title">
        <h2>Results table</h2>
        <span class="pill">Best GH/s (orange) • Best J/TH (green)</span>
      </div>
      <div id="tableContainer" style="overflow-x:auto;font-size:0.85rem;">
        <div class="muted">Loading results…</div>
      </div>
    </section>

    <!-- Charts -->
    <section class="card">
      <div class="card-title">
        <h2>Charts</h2>
        <span class="pill">Frequency, power, hashrate, efficiency, fan %, error %, reject %</span>
      </div>

      <div id="chartsEmpty" class="muted" style="font-size:0.85rem;display:none;">
        No numeric data available to plot for this run.
      </div>

      <!-- Big overall timeline chart -->
      <div id="timelineWrapper">
        <label class="muted" style="font-size:0.8rem;">Overall test (step timeline)</label>
        <canvas id="chartTimeline" height="260"></canvas>
      </div>

      <!-- Smaller per-metric charts below -->
      <div class="charts-grid" id="chartsGrid">
        <div>
          <label class="muted" style="font-size:0.8rem;">Hashrate vs frequency</label>
          <canvas id="chartHashVsFreq" height="180"></canvas>
        </div>
        <div>
          <label class="muted" style="font-size:0.8rem;">Power vs frequency</label>
          <canvas id="chartPowerVsFreq" height="180"></canvas>
        </div>
        <div>
          <label class="muted" style="font-size:0.8rem;">Efficiency vs frequency</label>
          <canvas id="chartEffVsFreq" height="180"></canvas>
        </div>
      </div>
    </section>
	
	<!-- Heatmaps (grid sweeps only) -->
    <section class="card" id="heatmapSection" style="display:none;">
      <div class="card-title">
        <h2>Voltage / frequency heatmaps</h2>
        <span class="pill">Grid sweeps only</span>
      </div>

      <div id="heatmapMeta"
           class="muted"
           style="font-size:0.8rem;margin-bottom:0.5rem;">
      </div>

      <div class="heatmaps-grid">
        <div class="heatmap-card">
          <h3>Hashrate (GH/s)</h3>
          <div id="heatmapHashContainer"></div>
        </div>
        <div class="heatmap-card">
          <h3>Efficiency (J/TH)</h3>
          <div id="heatmapEffContainer"></div>
        </div>
        <div class="heatmap-card">
		  <div class="row" style="align-items:center;justify-content:space-between;gap:0.5rem;">
			<h3 id="heatmapMetricLabel" style="margin:0;">Error rate (%)</h3>
			<select id="heatmapMetricSelect" style="max-width:200px;">
			  <option value="err" selected>Error rate (%)</option>
			  <option value="reject">Reject rate (%)</option>
			  <option value="pow">Power (W)</option>
			  <option value="chip">Chip temp (°C)</option>
			  <option value="vr">VRM temp (°C)</option>
			  <option value="fanPct">Fan speed (%)</option>
			  <option value="fanRpm">Fan speed (RPM)</option>
			  <option value="expected">Expected hash rate (GH/s)</option>
			  <option value="hashPct">Hash % of expected (%)</option>
			</select>
		  </div>
		  <div id="heatmapErrContainer"></div>
		</div>

      </div>


      <div id="stableSuggestWrap"
           style="margin-top:0.9rem;padding-top:0.9rem;border-top:1px solid var(--border);">
        <div class="row" style="align-items:center;gap:0.75rem;flex-wrap:wrap;margin-bottom:0.5rem;">
          <div class="shrink" style="font-weight:600;">Suggested stable settings</div>

          <label class="row shrink" style="gap:0.45rem;align-items:center;margin-left:auto;">
            <input id="stableHighlightToggle" type="checkbox" checked>
            <span class="muted" style="font-size:0.8rem;">Highlight stable candidates</span>
          </label>

          <div id="stableSuggestMeta" class="muted" style="font-size:0.8rem;">–</div>
        </div>

        <div class="row" style="gap:0.6rem;flex-wrap:wrap;">
          <div style="min-width:130px;flex:1;">
            <label class="muted" style="font-size:0.75rem;">Error max (%)</label>
            <input id="stableErrMax" type="number" step="0.1" min="0" value="2.0">
          </div>
          <div style="min-width:130px;flex:1;">
            <label class="muted" style="font-size:0.75rem;">Reject max (%)</label>
            <input id="stableRejectMax" type="number" step="0.1" min="0" value="1.0">
          </div>
          <div style="min-width:130px;flex:1;">
            <label class="muted" style="font-size:0.75rem;">Chip headroom (°C)</label>
            <input id="stableTempMargin" type="number" step="1" min="0" value="2">
          </div>
          <div style="min-width:130px;flex:1;">
            <label class="muted" style="font-size:0.75rem;">VR headroom (°C)</label>
            <input id="stableVrMargin" type="number" step="1" min="0" value="2">
          </div>
          <div style="min-width:130px;flex:1;">
            <label class="muted" style="font-size:0.75rem;">Power headroom (W)</label>
            <input id="stablePowerMargin" type="number" step="0.5" min="0" value="2">
          </div>
          <div class="shrink" style="align-self:flex-end;">
            <button class="btn secondary shrink" id="stableApplyBtn">Recompute</button>
          </div>
        </div>

        <div id="stableSuggestResult" style="margin-top:0.6rem;font-size:0.9rem;">
          <span class="muted">–</span>
        </div>
      </div>


      <div class="muted" style="font-size:0.72rem;margin-top:0.4rem;">
        Columns are set core voltages (mV), rows are frequency (MHz).
        Colors go from red (worst) to green (best).
		Purple cells mark grid points that hit an error or safety limit.
        Empty cells mean that particular combo wasn’t measured or failed early.
      </div>
    </section>

    <!-- Raw JSON (optional) -->
    <section class="card">
      <details class="raw-json">
        <summary>Show raw JSON results (for debugging)</summary>
        <pre id="rawJsonPre" class="mono" style="font-size:0.72rem;max-height:260px;overflow:auto;margin-top:0.4rem;"></pre>
      </details>
    </section>
  </div>

  <!-- Chart.js from CDN -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script>
    const root = document.documentElement;
    const apiBase = ""; // same origin

    const themeToggle = document.getElementById("themeToggle");
    const runIdLabel = document.getElementById("runIdLabel");
    const statusPill = document.getElementById("statusPill");
    const overviewBody = document.getElementById("overviewBody");
    const bestHashrateChip = document.getElementById("bestHashrateChip");
    const bestEfficiencyChip = document.getElementById("bestEfficiencyChip");
    const csvLink = document.getElementById("csvLink");
    const notesTextarea = document.getElementById("notesTextarea");
    const saveNotesBtn = document.getElementById("saveNotesBtn");
    const notesStatus = document.getElementById("notesStatus");
    const tableContainer = document.getElementById("tableContainer");
    const rawJsonPre = document.getElementById("rawJsonPre");
    const chartsGrid = document.getElementById("chartsGrid");
    const chartsEmpty = document.getElementById("chartsEmpty");
    const timelineWrapper = document.getElementById("timelineWrapper");
	const heatmapSection = document.getElementById("heatmapSection");
    const heatmapMeta = document.getElementById("heatmapMeta");
    const heatmapHashContainer = document.getElementById("heatmapHashContainer");
    const heatmapEffContainer = document.getElementById("heatmapEffContainer");
    const heatmapErrContainer = document.getElementById("heatmapErrContainer");
	const heatmapMetricSelect = document.getElementById("heatmapMetricSelect");
	const heatmapMetricLabel = document.getElementById("heatmapMetricLabel");

	// Stable suggestion / highlighting controls (grid heatmaps only)
	const stableHighlightToggle = document.getElementById("stableHighlightToggle");
	const stableApplyBtn = document.getElementById("stableApplyBtn");


    function setTheme(theme) {
      root.setAttribute("data-theme", theme);
      localStorage.setItem("bb_theme", theme);
    }
	
	function describeErrorReason(code) {
      if (!code) return "";
      const upper = String(code).toUpperCase();
      switch (upper) {
        case "ERROR_RATE_TOO_HIGH":
          return "ASIC error rate exceeded threshold";
        case "ZERO_HASHRATE":
          return "average hashrate was zero";
        case "NO_DATA_COLLECTED":
          return "no valid samples collected";
        default:
          return upper.replace(/_/g, " ").toLowerCase();
      }
    }

    themeToggle.addEventListener("click", () => {
      const next = root.getAttribute("data-theme") === "dark" ? "light" : "dark";
      setTheme(next);
    });
    setTheme(localStorage.getItem("bb_theme") || "dark");

    function getRunIdFromQuery() {
      const params = new URLSearchParams(window.location.search);
      return params.get("run");
    }

    function fmtNumber(value, digits) {
      if (value === null || value === undefined) return "–";
      const n = Number(value);
      if (!isFinite(n)) return "–";
      return n.toFixed(digits);
    }

    function toNumOrNull(value) {
      if (value === null || value === undefined) return null;
      const n = Number(value);
      return isFinite(n) ? n : null;
    }
	
	function isZeroishHashrate(hr, expected) {
	  const h = toNumOrNull(hr);
	  if (h === null) return false;

	  const exp = toNumOrNull(expected);

	  // True zero or negative → definitely bad.
	  if (h <= 0) return true;

	  // If we know the expected hashrate, treat anything below 0.1% of expected as "zero".
	  if (exp !== null && exp > 0 && h < exp * 0.001) {
		return true;
	  }

	  // Fallback: ultra‑low absolute value in GH/s is also "zero-ish".
	  // (Real grid points for this profile are in the 4–7 TH/s range.)
	  return h < 1; // 1 GH/s is still tiny compared to normal points.
	}

	function keyVF(v, f) { return `${v}|${f}`; }

	function readNum(id, fallback) {
	  const el = document.getElementById(id);
	  const v = el ? Number(el.value) : NaN;
	  return Number.isFinite(v) ? v : fallback;
	}

	function getStableHighlightEnabled() {
	  return stableHighlightToggle ? !!stableHighlightToggle.checked : true;
	}

	function computeStableSuggestion(points, cfg, lookup) {
	  const maxTemp = toNumOrNull(cfg?.max_temp ?? cfg?.maxTemp);
	  const maxVr   = toNumOrNull(cfg?.max_vr_temp ?? cfg?.maxVrTemp);
	  const maxPow  = toNumOrNull(cfg?.max_power ?? cfg?.maxPower);

	  const errDefault = toNumOrNull(cfg?.error_rate_warn_threshold);
	  const errMax = readNum("stableErrMax", errDefault ?? 2.0);
	  const rejMax = readNum("stableRejectMax", 1.0);
	  const tMargin = readNum("stableTempMargin", 2);
	  const vrMargin = readNum("stableVrMargin", 2);
	  const pMargin = readNum("stablePowerMargin", 2);

	  const tLimit  = maxTemp == null ? null : (maxTemp - tMargin);
	  const vrLimit = maxVr   == null ? null : (maxVr - vrMargin);
	  const pLimit  = maxPow  == null ? null : (maxPow - pMargin);

	  const stable = [];
	  const stableKeys = new Set();

	  for (const p of (points || [])) {
		const v = toNumOrNull(p.coreVoltage ?? p.vcore ?? p.core_voltage);
		const f = toNumOrNull(p.frequency ?? p.freq ?? p.frequency_mhz);
		if (v == null || f == null) continue;

		const entry = lookup[keyVF(v, f)];
		if (!entry) continue;

		const zeroish = isZeroishHashrate(entry.hashrate, entry.expected);
		const isErrorCell = !!entry.errorReason || zeroish;
		if (isErrorCell) continue;

		const hr  = toNumOrNull(entry.hashrate);
		const eff = toNumOrNull(entry.eff);
		if (hr == null || eff == null) continue;

		const t  = toNumOrNull(entry.chipTemp);
		const vr = toNumOrNull(entry.vrTemp);
		const pw = toNumOrNull(entry.power);

		if (tLimit  != null && t  != null && t  > tLimit)  continue;
		if (vrLimit != null && vr != null && vr > vrLimit) continue;
		if (pLimit  != null && pw != null && pw > pLimit)  continue;

		const err = toNumOrNull(entry.err);
		if (err != null && err > errMax) continue;

		const rej = toNumOrNull(entry.reject);
		if (rej != null && rej > rejMax) continue;

		const k = keyVF(v, f);
		stableKeys.add(k);
		stable.push({ k, v, f, hr, eff, err, rej, t, vr, pw });
	  }

	  stable.sort((a, b) => {
		if (b.hr !== a.hr) return b.hr - a.hr;            // highest hashrate
		const ae = a.err ?? 0, be = b.err ?? 0;
		if (ae !== be) return ae - be;                   // lower errors
		const ar = a.rej ?? 0, br = b.rej ?? 0;
		if (ar !== br) return ar - br;                   // lower rejects
		if (a.eff !== b.eff) return a.eff - b.eff;       // better efficiency
		const at = a.t ?? 0, bt = b.t ?? 0;
		if (at !== bt) return at - bt;                   // cooler
		const ap = a.pw ?? 0, bp = b.pw ?? 0;
		if (ap !== bp) return ap - bp;                   // lower power
		return 0;
	  });

	  return {
		stableKeys,
		best: stable[0] || null,
		limits: { tLimit, vrLimit, pLimit, errMax, rejMax }
	  };
	}

	function renderStableSuggestionUI(stable) {
	  const metaEl = document.getElementById("stableSuggestMeta");
	  const outEl  = document.getElementById("stableSuggestResult");
	  if (!metaEl || !outEl) return;

	  const highlightOff = !getStableHighlightEnabled();
	  const count = stable?.stableKeys?.size ?? 0;
	  metaEl.textContent = `${count} points meet stability criteria` + (highlightOff ? " (highlighting off)" : "");

	  if (!stable || !stable.best) {
		outEl.innerHTML = `<span class="muted">No points meet stability criteria.</span>`;
		return;
	  }

	  const b = stable.best;
	  outEl.innerHTML =
		`Recommend <strong>${fmtNumber(b.hr, 1)} GH/s</strong> @ ` +
		`<span class="mono">${fmtNumber(b.v, 0)} mV</span> / <span class="mono">${fmtNumber(b.f, 0)} MHz</span>` +
		` — <span class="mono">${fmtNumber(b.eff, 2)} J/TH</span>` +
		(b.err != null ? `, err <span class="mono">${fmtNumber(b.err, 2)}%</span>` : ``) +
		(b.rej != null ? `, reject <span class="mono">${fmtNumber(b.rej, 2)}%</span>` : ``) +
		(b.pw  != null ? `, <span class="mono">${fmtNumber(b.pw, 2)} W</span>` : ``) +
		(b.t   != null ? `, chip <span class="mono">${fmtNumber(b.t, 1)}°C</span>` : ``) +
		(b.vr  != null ? `, VR <span class="mono">${fmtNumber(b.vr, 1)}°C</span>` : ``);
	}

	function getHeatmapHighlight(lastCtx) {
	  if (!lastCtx?.stable) return null;
	  if (!getStableHighlightEnabled()) return null;
	  return {
		stableKeys: lastCtx.stable.stableKeys,
		bestKey: lastCtx.stable.best?.k || null,
	  };
	}

	function redrawHeatmapsFromContext() {
	  if (!lastHeatmapContext) return;
	  const { voltages, freqs, lookup, rowMeta } = lastHeatmapContext;
	  const highlight = getHeatmapHighlight(lastHeatmapContext);
buildSingleHeatmap(heatmapHashContainer, voltages, freqs, lookup, "hashrate", {
		label: "GH/s",
		invert: false,
		decimals: 1,
	  }, rowMeta, highlight);

	  buildSingleHeatmap(heatmapEffContainer, voltages, freqs, lookup, "eff", {
		label: "J/TH",
		invert: true,
		decimals: 2,
	  }, rowMeta, highlight);

	  const selectedKey = (heatmapMetricSelect && heatmapMetricSelect.value) || "err";
	  const metricCfg = HEATMAP_METRICS[selectedKey] || HEATMAP_METRICS.err;

	  if (heatmapMetricLabel) {
		heatmapMetricLabel.textContent = metricCfg.title;
	  }

	  buildSingleHeatmap(
		heatmapErrContainer,
		voltages,
		freqs,
		lookup,
		metricCfg.key,
		metricCfg,
		rowMeta,
		highlight
	  );

	  // Update the text meta each redraw so it can reflect "highlighting off"
	  renderStableSuggestionUI(lastHeatmapContext.stable);
	}



    function extractPoints(resultsRoot) {
      if (!resultsRoot) return [];
      if (Array.isArray(resultsRoot.points)) return resultsRoot.points;
      if (Array.isArray(resultsRoot.allPoints)) return resultsRoot.allPoints;
      if (Array.isArray(resultsRoot.results)) return resultsRoot.results;
      if (Array.isArray(resultsRoot.data)) return resultsRoot.data;
      return [];
    }

    function findBestIndices(points) {
      let bestHashIndex = -1;
      let bestHashValue = -Infinity;
      let bestEffIndex = -1;
      let bestEffValue = Infinity;

      points.forEach((p, idx) => {
        const hr = toNumOrNull(p.averageHashRate ?? p.hashRate ?? p.average_hashrate);
        if (hr !== null && hr > bestHashValue) {
          bestHashValue = hr;
          bestHashIndex = idx;
        }

        const eff = toNumOrNull(p.efficiencyJTH ?? p.efficiency ?? p.j_per_th);
        if (eff !== null && eff < bestEffValue) {
          bestEffValue = eff;
          bestEffIndex = idx;
        }
      });

      if (!isFinite(bestHashValue)) bestHashIndex = -1;
      if (!isFinite(bestEffValue)) bestEffIndex = -1;

      return { bestHashIndex, bestEffIndex, bestHashValue, bestEffValue };
    }
	
	const HEATMAP_METRICS = {
	  err: {
		key: "err",
		label: "error rate (%)",
		title: "Error rate (%)",
		invert: true,   // lower error = greener
		decimals: 2,
	  },
	  reject: {
		key: "reject",
		label: "reject rate (%)",
		title: "Reject rate (%)",
		invert: true,
		decimals: 2,
	  },
	  pow: {
		key: "pow",
		label: "power (W)",
		title: "Power (W)",
		invert: true,   // treat lower power as "better" for color
		decimals: 1,
	  },
	  chip: {
		key: "chip",
		label: "chip temp (°C)",
		title: "Chip temperature (°C)",
		invert: true,   // lower temp = better
		decimals: 1,
	  },
	  vr: {
		key: "vr",
		label: "VRM temp (°C)",
		title: "VRM temperature (°C)",
		invert: true,
		decimals: 1,
	  },
	  fanPct: {
		key: "fanPct",
		label: "fan speed (%)",
		title: "Fan speed (%)",
		invert: true,   // lower fan % = "better" noise-wise
		decimals: 0,
	  },
	  fanRpm: {
		key: "fanRpm",
		label: "fan speed (RPM)",
		title: "Fan speed (RPM)",
		invert: true,
		decimals: 0,
	  },
	  expected: {
		key: "expected",
		label: "expected hash rate (GH/s)",
		title: "Expected hash rate (GH/s)",
		invert: false,
		decimals: 0,
	  },
	  hashPct: {
		key: "hashPct",
		label: "hash % of expected (%)",
		title: "Hash % of expected (%)",
		invert: false,
		decimals: 1,
	  },
	};

	// We'll stash the last-computed grid so the selector
	// can redraw without re-fetching data.
	let lastHeatmapContext = null;

	
	function buildHeatmaps(points, resultsRoot, run) {
	  if (!heatmapSection) return;

	  let cfg = run.config || {};
	  // Prefer config from the results JSON (always an object).
	  if (resultsRoot && typeof resultsRoot.config === "object") {
		cfg = resultsRoot.config;
	  } else if (run && typeof run.config === "object") {
		// Fallback to parsed config from /api (live runs or parsed config_json)
		cfg = run.config;
	  }
	  const mode = (cfg.sweep_mode || cfg.sweepMode || "").toLowerCase();

	  if (mode !== "grid") {
		heatmapSection.style.display = "none";
		return;
	  }

	  const validPoints = points.filter((p) => {
		const v = p.coreVoltage ?? p.vcore ?? p.core_voltage;
		const f = p.frequency ?? p.freq ?? p.frequency_mhz;
		return v != null && f != null;
	  });

	  if (!validPoints.length) {
		heatmapSection.style.display = "none";
		return;
	  }

	  const voltages = Array.from(
		new Set(validPoints.map((p) => Number(p.coreVoltage ?? p.vcore ?? p.core_voltage)))
	  ).sort((a, b) => a - b);

	  const freqs = Array.from(
		new Set(validPoints.map((p) => Number(p.frequency ?? p.freq ?? p.frequency_mhz)))
	  ).sort((a, b) => a - b);

	  if (!voltages.length || !freqs.length) {
		heatmapSection.style.display = "none";
		return;
	  }
	  
	  // NEW: stack vertically for large grids
	  const isLargeGrid =
	    voltages.length >= 5 ||      // many voltage steps
	    freqs.length >= 6  ||        // many freq steps
	    (voltages.length * freqs.length) >= 30; // or just lots of points

	  heatmapSection.classList.toggle("heatmaps-large", isLargeGrid);

	  heatmapSection.style.display = "block";
	  heatmapMeta.textContent =
		`Grid size: ${voltages.length} voltages × ${freqs.length} frequencies (${validPoints.length} points).`;

	  // NEW: track per-voltage metadata
	  const rowMeta = {};

	  const lookup = {};
	  validPoints.forEach((p) => {
		const v = Number(p.coreVoltage ?? p.vcore ?? p.core_voltage);
		const f = Number(p.frequency ?? p.freq ?? p.frequency_mhz);
		const key = `${v}|${f}`;
		const errorReason = p.errorReason || p.error_reason || null;

		const hashrate = toNumOrNull(p.averageHashRate ?? p.hashRate ?? p.average_hashrate);
		const expected = toNumOrNull(p.expectedHashRate ?? p.expectedHashrate ?? p.expected_hashrate);
		const hashPct = (hashrate != null && expected != null && expected > 0)
		  ? (hashrate / expected) * 100
		  : null;

		lookup[key] = {
		  hashrate,
		  expected,
		  hashPct,
		  eff:      toNumOrNull(p.efficiencyJTH ?? p.efficiency ?? p.j_per_th),
		  err:      toNumOrNull(p.errorPercentage ?? p.error_pct ?? p.errorRate),
		  reject:   toNumOrNull(p.rejectRate ?? p.reject_rate),
		  errorReason,
		  // NEW: extra metrics for the selector
		  pow:     toNumOrNull(p.averagePower ?? p.power ?? p.power_watts),
		  chip:    toNumOrNull(p.averageTemperature ?? p.temp ?? p.temperature),
		  vr:      toNumOrNull(p.averageVRTemp ?? p.vrTemp ?? p.vr_temperature),
		  fanPct:  toNumOrNull(p.fanSpeed ?? p.fan_pct ?? p.fanspeed),
		  fanRpm:  toNumOrNull(p.fanRPM ?? p.fan_rpm ?? p.fanrpm),
		};

		if (!rowMeta[v]) {
		  rowMeta[v] = { maxFreq: f, hadFailure: false };
		} else if (f > rowMeta[v].maxFreq) {
		  rowMeta[v].maxFreq = f;
		}
		if (errorReason) {
		  rowMeta[v].hadFailure = true;
		}
	  });
	  
	  // Save context for selector-driven redraws
	  lastHeatmapContext = { voltages, freqs, lookup, rowMeta, points, cfg, stable: null };

	  // Initialize defaults for the stability controls from config (when present)
	  const errInput = document.getElementById("stableErrMax");
	  if (errInput && (run?.config?.error_rate_warn_threshold != null || cfg?.error_rate_warn_threshold != null)) {
		errInput.value = toNumOrNull(cfg?.error_rate_warn_threshold) ?? errInput.value;
	  }

	  // Compute & render "suggested stable" candidate set
	  const stable = computeStableSuggestion(points, cfg, lookup);
	  lastHeatmapContext.stable = stable;
	  renderStableSuggestionUI(stable);

	  const highlight = getHeatmapHighlight(lastHeatmapContext);



	  buildSingleHeatmap(heatmapHashContainer, voltages, freqs, lookup, "hashrate", {
		label: "GH/s",
		invert: false,
		decimals: 1,
	  }, rowMeta, highlight);

	  buildSingleHeatmap(heatmapEffContainer, voltages, freqs, lookup, "eff", {
		label: "J/TH",
		invert: true,
		decimals: 2,
	  }, rowMeta, highlight);

	  // Third one uses the selector:
	  const selectedKey = (heatmapMetricSelect && heatmapMetricSelect.value) || "err";
	  const metricCfg = HEATMAP_METRICS[selectedKey] || HEATMAP_METRICS.err;

	  if (heatmapMetricLabel) {
	    heatmapMetricLabel.textContent = metricCfg.title;
	  }

	  buildSingleHeatmap(
	    heatmapErrContainer,          // still using this container
	    voltages,
	    freqs,
	    lookup,
	    metricCfg.key,
	    metricCfg,
	    rowMeta,
		highlight
	  );
	}
	
	if (heatmapMetricSelect) {
	  heatmapMetricSelect.addEventListener("change", () => {
		if (!lastHeatmapContext) return;

		const { voltages, freqs, lookup, rowMeta } = lastHeatmapContext;
		const highlight = getHeatmapHighlight(lastHeatmapContext);
		const selectedKey = heatmapMetricSelect.value || "err";
		const metricCfg = HEATMAP_METRICS[selectedKey] || HEATMAP_METRICS.err;

		if (heatmapMetricLabel) {
		  heatmapMetricLabel.textContent = metricCfg.title;
		}

		buildSingleHeatmap(
		  heatmapErrContainer,
		  voltages,
		  freqs,
		  lookup,
		  metricCfg.key,
		  metricCfg,
		  rowMeta,
		  highlight
		);
	  });

	// Stability recompute + highlight toggle
	if (stableApplyBtn) {
	  stableApplyBtn.addEventListener("click", () => {
		if (!lastHeatmapContext) return;
		const { points, cfg, lookup } = lastHeatmapContext;
		const stable = computeStableSuggestion(points, cfg, lookup);
		lastHeatmapContext.stable = stable;
		renderStableSuggestionUI(stable);
		redrawHeatmapsFromContext();
	  });
	}

	if (stableHighlightToggle) {
	  stableHighlightToggle.addEventListener("change", () => {
		// Just redraw; we keep the suggestion, only toggling outlines.
		redrawHeatmapsFromContext();
	  });
	}

	}

    function buildSingleHeatmap(container, voltages, freqs, lookup, key, opts, rowMeta, highlight) {
	  const values = [];

	  voltages.forEach((v) => {
	    freqs.forEach((f) => {
		  const entry = lookup[`${v}|${f}`];
		  if (!entry) return;

		  const val = entry[key];

		  const zeroish = isZeroishHashrate(entry.hashrate, entry.expected);

		  // Treat explicit errorReason and zero-ish hashrate as "error cells"
		  const isErrorCell = !!entry.errorReason || zeroish;

		  if (!isErrorCell && val != null && isFinite(val)) {
		    values.push(val);
		  }
	    });
	  });


	  if (!values.length) {
		container.innerHTML =
		  `<div class="muted" style="font-size:0.75rem;">No ${opts.label} data for this grid.</div>`;
		return;
	  }

	  const min = Math.min(...values);
	  const max = Math.max(...values);
	  const span = max - min || 1;

	  function colorFor(value) {
		if (value == null || !isFinite(value)) return "transparent";
		let t = (value - min) / span;
		if (opts.invert) t = 1 - t;
		t = Math.max(0, Math.min(1, t));
		const hue = 120 * t; // 0 = red, 120 = green
		return `hsl(${hue}, 70%, 45%)`;
	  }

	  // Columns = voltages (x axis), low → high
  	  // Rows = frequencies (y axis), high → low (so low is at the bottom)
	  let html = '<table class="heatmap-grid"><thead><tr><th>MHz / mV</th>';
	  voltages.forEach((v) => {
	    html += `<th>${v}</th>`;
	  });
	  html += "</tr></thead><tbody>";

	  // Render rows from highest freq at the top to lowest at the bottom
	  const freqRows = [...freqs].sort((a, b) => b - a);

	  freqRows.forEach((f) => {
	    html += `<tr><th>${f}</th>`;

	    voltages.forEach((v) => {
	  	  const meta = rowMeta?.[v];
		  const entry = lookup[`${v}|${f}`];
		  const baseVal = entry ? entry[key] : null;

		  let bg;
		  let text = "";
		  let extraClass = "";

		  const zeroish = entry ? isZeroishHashrate(entry.hashrate, entry.expected) : false;

		  const isErrorCell =
		    entry &&
		    (
			  entry.errorReason ||
			  zeroish
		    );

		  if (isErrorCell) {
			// Match index mini heatmap: failed points are purple.
			bg = "hsl(270, 80%, 45%)";
			extraClass = "heatmap-failed";
			text = "";
		  } else if (!entry && meta && meta.hadFailure && f > meta.maxFreq) {
			// We stopped the sweep at a lower freq for this voltage → skipped
			bg = "rgba(148, 163, 184, 0.4)";
			extraClass = "heatmap-skipped";
		  } else {
			bg = colorFor(baseVal);
			text =
			  baseVal == null || !isFinite(baseVal)
				? ""
				: fmtNumber(baseVal, opts.decimals);
		  }

		  
		  // Optional stability highlighting (outlines only)
		  if (highlight && entry && !isErrorCell) {
			const k = keyVF(v, f);
			if (highlight.stableKeys && highlight.stableKeys.has(k)) {
			  extraClass = extraClass ? (extraClass + " heatmap-stable") : "heatmap-stable";
			}
			if (highlight.bestKey && highlight.bestKey === k) {
			  extraClass = extraClass ? (extraClass + " heatmap-best-stable") : "heatmap-best-stable";
			}
		  }

html += `<td class="${extraClass}" style="background:${bg};"><span class="heatmap-cell-value">${text}</span></td>`;
	    });

	    html += "</tr>";
	  });

	html += "</tbody></table>";
	container.innerHTML = html;


	  html += "</tbody></table>";
	  container.innerHTML = html;
	}

    function renderTable(points) {
      if (!points.length) {
        tableContainer.innerHTML = `<div class="muted">No results recorded for this run.</div>`;
        return;
      }

      const { bestHashIndex, bestEffIndex } = findBestIndices(points);

      const rowsHtml = points.map((p, idx) => {
        const step = p.step ?? p.index ?? (idx + 1);
        const v = p.coreVoltage ?? p.vcore ?? p.core_voltage;
        const f = p.frequency ?? p.freq ?? p.frequency_mhz;
        const hr = p.averageHashRate ?? p.hashRate ?? p.average_hashrate;
        const pow = p.averagePower ?? p.power ?? p.power_watts;
        const eff = p.efficiencyJTH ?? p.efficiency ?? p.j_per_th;
        const t = p.averageTemperature ?? p.temp ?? p.temperature;
        const vrT = p.averageVRTemp ?? p.vrTemp ?? p.vr_temperature;
        const fanPct = p.fanSpeed ?? p.fan_pct ?? p.fanspeed;
        const fanRpm = p.fanRPM ?? p.fan_rpm ?? p.fanrpm;
        const errPct = p.errorPct ?? p.error_percentage ?? p.errorPercentage ?? p.error_percent;
		const rejectPct = p.rejectRate ?? p.reject_rate;
		const sharesRej = p.sharesRejected ?? p.shares_rejected;
		const sharesTotal = p.sharesTotal ?? p.shares_total;

        const hrClass = idx === bestHashIndex ? "best-hashrate" : "";
        const effClass = idx === bestEffIndex ? "best-efficiency" : "";

        return `
          <tr>
            <td class="mono">${step}</td>
            <td class="mono">${fmtNumber(v, 0)}</td>
            <td class="mono">${fmtNumber(f, 0)}</td>
            <td class="mono ${hrClass}">${fmtNumber(hr, 1)}</td>
            <td class="mono">${fmtNumber(pow, 2)}</td>
            <td class="mono ${effClass}">${fmtNumber(eff, 2)}</td>
			<td class="mono">${errPct === null || errPct === undefined ? "–" : fmtNumber(errPct, 2)}</td>
			<td class="mono">${rejectPct === null || rejectPct === undefined ? "–" : fmtNumber(rejectPct, 2)}</td>
			<td class="mono">${sharesRej === null || sharesRej === undefined ? "–" : fmtNumber(sharesRej, 0)}</td>
			<td class="mono">${sharesTotal === null || sharesTotal === undefined ? "–" : fmtNumber(sharesTotal, 0)}</td>
            <td class="mono">${fmtNumber(t, 1)}</td>
            <td class="mono">${fmtNumber(vrT, 1)}</td>
            <td class="mono">${fanPct === null || fanPct === undefined ? "–" : fmtNumber(fanPct, 0)}</td>
            <td class="mono">${fanRpm === null || fanRpm === undefined ? "–" : fmtNumber(fanRpm, 0)}</td>
          </tr>
        `;
      }).join("");

      tableContainer.innerHTML = `
        <table>
          <thead>
            <tr>
              <th>#</th>
              <th>Core mV</th>
              <th>MHz</th>
              <th>GH/s</th>
              <th>Power (W)</th>
              <th>J/TH</th>
              <th>Error %</th>
			  <th>Reject %</th>
			  <th>Rej shares</th>
			  <th>Total shares</th>
              <th>°C</th>
              <th>VR °C</th>
              <th>Fan %</th>
              <th>Fan RPM</th>
            </tr>
          </thead>
          <tbody>
            ${rowsHtml}
          </tbody>
        </table>
      `;
    }

    function renderOverview(run, resultsRoot, points) {
      runIdLabel.textContent = run.id || "unknown";

      const status = (run.status || "").toLowerCase();
      statusPill.textContent = run.status || "unknown";

      const started = (run.started_at || "").split(".")[0] || "–";
      const finished = (run.finished_at || "").split(".")[0] || "–";
      const device = run.device_type || run.deviceType || "unknown device";
      const ip = run.bitaxe_ip || "–";
      const profile = run.profile_name || run.profile || "–";
      const totalPoints = points.length || "0";
	  
	  // NEW: derive a friendly failure reason
      const rawErr = (run.error_reason || run.errorReason || "");
      const errorReason = rawErr ? String(rawErr).toUpperCase() : "";
      const threshold = toNumOrNull(
        run.config?.error_rate_warn_threshold ??
        run.config?.errorRateWarnThreshold
      );
      let failureReasonLine = "";
      // Only show a failure reason when the overall run actually failed.
	  if (status === "failed") {
	    let msg;
	    if (errorReason === "ERROR_RATE_TOO_HIGH") {
		  const suffix =
		    threshold != null ? ` (threshold ${threshold.toFixed(2)}%)` : "";
		  msg = `failed because ASIC error rate exceeded the configured threshold${suffix}.`;
	    } else if (errorReason === "ZERO_HASHRATE") {
		  msg = "failed because average hashrate was zero.";
	    } else if (errorReason) {
		  msg = `failed due to ${describeErrorReason(errorReason)}.`;
	    } else {
		  // Failed but no explicit errorReason → generic hashrate-based failure.
		  msg = "failed because hashrate stayed below the expected target.";
	    }

	    if (msg) {
		  failureReasonLine = `<br/>Failure reason: <span class="mono">${msg}</span>`;
	    }
	  }

      overviewBody.innerHTML = `
        <div style="margin-bottom:0.35rem;">
          <strong>${device}</strong> @ <span class="mono">${ip}</span>
        </div>
        <div style="font-size:0.85rem;">
          Status: <span class="mono">${run.status || "unknown"}</span><br/>
          Profile: <span class="mono">${profile}</span><br/>
          Started: <span class="mono">${started}</span><br/>
          Finished: <span class="mono">${finished}</span><br/>
          Steps completed: <span class="mono">${totalPoints}</span>
		  ${failureReasonLine}
        </div>
      `;

      // Best points from summarized data if available, otherwise derive
      let bestHashPoint = null;
      let bestEffPoint = null;

      if (Array.isArray(resultsRoot?.topPerformers) && resultsRoot.topPerformers.length) {
        bestHashPoint = resultsRoot.topPerformers[0];
      }

      if (Array.isArray(resultsRoot?.mostEfficient) && resultsRoot.mostEfficient.length) {
        bestEffPoint = resultsRoot.mostEfficient[0];
      }

      const { bestHashIndex, bestEffIndex, bestHashValue, bestEffValue } = findBestIndices(points);

      if (!bestHashPoint && bestHashIndex >= 0) {
        bestHashPoint = points[bestHashIndex];
      }
      if (!bestEffPoint && bestEffIndex >= 0) {
        bestEffPoint = points[bestEffIndex];
      }

      if (bestHashPoint) {
        const hr = fmtNumber(bestHashPoint.averageHashRate ?? bestHashPoint.hashRate, 1);
        const v = bestHashPoint.coreVoltage ?? bestHashPoint.vcore;
        const f = bestHashPoint.frequency ?? bestHashPoint.freq;
        bestHashrateChip.innerHTML =
          `Best hashrate: <strong>${hr} GH/s</strong> @ ` +
          `<span class="mono">${fmtNumber(v,0)} mV</span> / ` +
          `<span class="mono">${fmtNumber(f,0)} MHz</span>`;
      } else if (isFinite(bestHashValue)) {
        bestHashrateChip.textContent = `Best hashrate: ${fmtNumber(bestHashValue,1)} GH/s`;
      } else {
        bestHashrateChip.textContent = "Best hashrate: –";
      }

      if (bestEffPoint) {
        const eff = fmtNumber(bestEffPoint.efficiencyJTH ?? bestEffPoint.efficiency, 2);
        const v = bestEffPoint.coreVoltage ?? bestEffPoint.vcore;
        const f = bestEffPoint.frequency ?? bestEffPoint.freq;
        bestEfficiencyChip.innerHTML =
          `Best efficiency: <strong>${eff} J/TH</strong> @ ` +
          `<span class="mono">${fmtNumber(v,0)} mV</span> / ` +
          `<span class="mono">${fmtNumber(f,0)} MHz</span>`;
      } else if (isFinite(bestEffValue)) {
        bestEfficiencyChip.textContent = `Best efficiency: ${fmtNumber(bestEffValue,2)} J/TH`;
      } else {
        bestEfficiencyChip.textContent = "Best efficiency: –";
      }
    }

    function buildCharts(points) {
      if (!points.length || typeof Chart === "undefined") {
        chartsGrid.style.display = "none";
        chartsEmpty.style.display = "block";
        if (timelineWrapper) timelineWrapper.style.display = "none";
        return;
      }

      chartsGrid.style.display = "grid";
      chartsEmpty.style.display = "none";
      if (timelineWrapper) timelineWrapper.style.display = "block";

      const labelsFreq = points.map((p) => p.frequency ?? p.freq ?? p.frequency_mhz ?? null);
      const labelsSteps = points.map((p, idx) => p.step ?? p.index ?? (idx + 1));

      const hrData = points.map((p) => toNumOrNull(p.averageHashRate ?? p.hashRate ?? p.average_hashrate));
      const powData = points.map((p) => toNumOrNull(p.averagePower ?? p.power ?? p.power_watts));
      const effData = points.map((p) => toNumOrNull(p.efficiencyJTH ?? p.efficiency ?? p.j_per_th));
      const freqData = points.map((p) => toNumOrNull(p.frequency ?? p.freq ?? p.frequency_mhz));
      const vcoreData = points.map((p) => toNumOrNull(p.coreVoltage ?? p.vcore ?? p.core_voltage));
	  // NEW: zero-ish mask + cleaned efficiency data
	  const zeroishMask = points.map((p, idx) =>
	    isZeroishHashrate(
		  hrData[idx],
		  p.expectedHashrate ?? p.expected_hashrate
	    )
	  );

	  const effDataClean = effData.map((val, idx) =>
	    zeroishMask[idx] ? null : val
	  );
      const fanPctData = points.map((p) =>
        toNumOrNull(p.fanSpeed ?? p.fan_pct ?? p.fanspeed)
      );
      const errPctData = points.map((p) =>
        toNumOrNull(p.errorPct ?? p.error_percentage ?? p.errorPercentage ?? p.error_percent)
      );

      const ctxHashVsFreq = document.getElementById("chartHashVsFreq").getContext("2d");
      const ctxPowerVsFreq = document.getElementById("chartPowerVsFreq").getContext("2d");
      const ctxEffVsFreq = document.getElementById("chartEffVsFreq").getContext("2d");
      const ctxTimeline = document.getElementById("chartTimeline").getContext("2d");

      new Chart(ctxHashVsFreq, {
        type: "line",
        data: {
          labels: labelsFreq,
          datasets: [
            {
              label: "Hashrate (GH/s)",
              data: hrData,
              spanGaps: true
            }
          ]
        },
        options: {
          responsive: true,
          plugins: {
            legend: { display: true }
          },
          scales: {
            x: {
              title: { display: true, text: "Frequency (MHz)" }
            },
            y: {
              title: { display: true, text: "GH/s" }
            }
          }
        }
      });

      new Chart(ctxPowerVsFreq, {
        type: "line",
        data: {
          labels: labelsFreq,
          datasets: [
            {
              label: "Power (W)",
              data: powData,
              spanGaps: true
            }
          ]
        },
        options: {
          responsive: true,
          plugins: {
            legend: { display: true }
          },
          scales: {
            x: {
              title: { display: true, text: "Frequency (MHz)" }
            },
            y: {
              title: { display: true, text: "Power (W)" }
            }
          }
        }
      });

      new Chart(ctxEffVsFreq, {
        type: "line",
        data: {
          labels: labelsFreq,
          datasets: [
            {
              label: "Efficiency (J/TH)",
              data: effDataClean,
              spanGaps: true
            }
          ]
        },
        options: {
          responsive: true,
          plugins: {
            legend: { display: true }
          },
          scales: {
            x: {
              title: { display: true, text: "Frequency (MHz)" }
            },
            y: {
              title: { display: true, text: "J/TH" }
            }
          }
        }
      });

      new Chart(ctxTimeline, {
        type: "line",
        data: {
          labels: labelsSteps,
          datasets: [
            {
              label: "Frequency (MHz)",
              data: freqData,
              spanGaps: true,
              yAxisID: "yFreq"
            },
            {
              label: "Core mV",
              data: vcoreData,
              spanGaps: true,
              yAxisID: "yFreq"
            },
            {
              label: "Power (W)",
              data: powData,
              spanGaps: true,
              yAxisID: "yPower"
            },
            {
              label: "Hashrate (GH/s)",
              data: hrData,
              spanGaps: true,
              yAxisID: "yHash"
            },
            {
              label: "Efficiency (J/TH)",
              data: effDataClean,
              spanGaps: true,
              yAxisID: "yEff"
            },
            {
              label: "Fan %",
              data: fanPctData,
              spanGaps: true,
              yAxisID: "yAux"
            },
            {
              label: "Error %",
              data: errPctData,
              spanGaps: true,
              yAxisID: "yAux"
            }
          ]
        },
        options: {
          responsive: true,
          plugins: {
            legend: { display: true }
          },
          scales: {
            x: {
              title: { display: true, text: "Step #" }
            },
            yHash: {
              type: "linear",
              position: "left",
              title: { display: true, text: "GH/s" }
            },
            yPower: {
              type: "linear",
              position: "right",
              title: { display: true, text: "Power (W)" },
              grid: { drawOnChartArea: false }
            },
            yFreq: {
              type: "linear",
              position: "right",
              title: { display: true, text: "Freq / Core mV" },
              grid: { drawOnChartArea: false },
              offset: true
            },
            yEff: {
              type: "linear",
              position: "left",
              title: { display: true, text: "J/TH" },
              grid: { drawOnChartArea: false }
            },
            yAux: {
              type: "linear",
              position: "right",
              title: { display: true, text: "Fan % / Error %" },
              grid: { drawOnChartArea: false }
            }
          }
        }
      });
    }

    async function saveNotes(runId, notes) {
      saveNotesBtn.disabled = true;
      saveNotesBtn.textContent = "Saving…";
      notesStatus.textContent = "";
      try {
        const res = await fetch(`${apiBase}/api/benchmarks/${encodeURIComponent(runId)}/notes`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ notes })
        });
        if (!res.ok) {
          let msg = "Failed to save notes.";
          try {
            const text = await res.text();
            if (text) msg = text;
          } catch (_) {}
          throw new Error(msg);
        }
        notesStatus.textContent = "Notes saved.";
      } catch (err) {
        console.error(err);
        notesStatus.textContent = err.message || "Failed to save notes.";
      } finally {
        saveNotesBtn.disabled = false;
        saveNotesBtn.textContent = "Save notes";
      }
    }

    (async () => {
      const runId = getRunIdFromQuery();
      if (!runId) {
        overviewBody.innerHTML = `<span class="muted">No run id specified in URL.</span>`;
        chartsGrid.style.display = "none";
        chartsEmpty.style.display = "block";
        tableContainer.innerHTML = `<div class="muted">No run selected.</div>`;
        return;
      }

      runIdLabel.textContent = runId;
      csvLink.href = `${apiBase}/api/benchmarks/${encodeURIComponent(runId)}/csv`;

      try {
        const res = await fetch(`${apiBase}/api/benchmarks/${encodeURIComponent(runId)}?include_results=true`);
        if (!res.ok) {
          let msg = "Failed to load run.";
          try {
            const txt = await res.text();
            if (txt) msg = txt;
          } catch (_) {}
          throw new Error(msg);
        }
        const run = await res.json();

        const resultsRoot = run.resultsFile || run;
        const points = extractPoints(resultsRoot);

        renderOverview(run, resultsRoot, points);
        renderTable(points);
        buildCharts(points);
		buildHeatmaps(points, resultsRoot, run);

        notesTextarea.value = run.notes || "";
        rawJsonPre.textContent = JSON.stringify(resultsRoot, null, 2);

        saveNotesBtn.addEventListener("click", () => {
          const notes = notesTextarea.value;
          saveNotes(run.id || runId, notes);
        });
      } catch (err) {
        console.error(err);
        overviewBody.innerHTML = `<span class="muted">${err.message || "Failed to load run data."}</span>`;
        tableContainer.innerHTML = `<div class="muted">Unable to render table.</div>`;
        chartsGrid.style.display = "none";
        chartsEmpty.style.display = "block";
      }
    })();
  </script>
</body>
</html>
