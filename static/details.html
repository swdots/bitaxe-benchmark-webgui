<!doctype html>
<html lang="en" data-theme="dark">
<head>
  <meta charset="utf-8" />
  <title>Benchmark run details</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #050711;
      --fg: #f9fafb;
      --muted: #94a3b8;
      --accent: #22c55e;
      --danger: #ef4444;
      --card: #0b1120;
      --border: #1f2937;
      --table-stripe: #020617;
    }
    [data-theme="light"] {
      --bg: #f9fafb;
      --fg: #020617;
      --muted: #6b7280;
      --accent: #16a34a;
      --danger: #b91c1c;
      --card: #ffffff;
      --border: #e5e7eb;
      --table-stripe: #f3f4f6;
    }
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text", sans-serif;
      background: radial-gradient(circle at top left, #111827 0, var(--bg) 40%);
      color: var(--fg);
    }
    a {
      color: var(--accent);
      text-decoration: none;
    }
    a:hover {
      text-decoration: underline;
    }
    .page {
      max-width: 1200px;
      margin: 0 auto;
      padding: 1rem 1rem 3rem;
    }
    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
      margin-bottom: 1rem;
    }
    header h1 {
      font-size: 1.4rem;
      margin: 0;
    }
    .sub {
      font-size: 0.85rem;
      color: var(--muted);
    }
    .card {
      background: color-mix(in srgb, var(--card) 92%, transparent);
      border-radius: 16px;
      padding: 1rem 1.2rem;
      border: 1px solid var(--border);
      box-shadow: 0 18px 45px rgba(15, 23, 42, 0.45);
      margin-bottom: 1rem;
    }
    .card-title {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.75rem;
    }
    .card-title h2 {
      font-size: 1rem;
      margin: 0;
    }
    .pill {
      font-size: 0.75rem;
      border-radius: 999px;
      padding: 0.2rem 0.6rem;
      border: 1px solid var(--border);
      color: var(--muted);
    }
    .row {
      display: flex;
      gap: 0.75rem;
      flex-wrap: wrap;
      align-items: center;
      margin-bottom: 0.4rem;
    }
    .row > * {
      flex: 1;
    }
    .row > .shrink {
      flex: 0 0 auto;
    }
    .btn {
      padding: 0.4rem 0.8rem;
      border-radius: 999px;
      border: 1px solid transparent;
      font-size: 0.85rem;
      cursor: pointer;
      background: var(--accent);
      color: white;
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
    }
    .btn.secondary {
      background: transparent;
      border-color: var(--border);
      color: var(--fg);
    }
    .btn.danger {
      background: var(--danger);
      color: white;
    }
    .btn:disabled {
      opacity: 0.5;
      cursor: default;
    }
    .muted {
      color: var(--muted);
    }
    .mono {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.8rem;
    }
    th,
    td {
      padding: 0.35rem 0.4rem;
      text-align: left;
      border-bottom: 1px solid var(--border);
    }
    th {
      font-weight: 500;
      color: var(--muted);
      white-space: nowrap;
    }
    tbody tr:nth-child(odd) {
      background: color-mix(in srgb, var(--table-stripe) 50%, transparent);
    }

    .best-hashrate {
      border: 1px solid #fb923c;
      box-shadow: 0 0 0 1px rgba(251, 146, 60, 0.5);
      background: rgba(251, 146, 60, 0.12);
    }
    .best-efficiency {
      border: 1px solid #22c55e;
      box-shadow: 0 0 0 1px rgba(34, 197, 94, 0.5);
      background: rgba(34, 197, 94, 0.12);
    }

    .charts-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: 1rem;
    }
	.heatmaps-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 1rem;
      margin-top: 0.75rem;
    }
    .heatmap-card h3 {
      font-size: 0.9rem;
      margin: 0 0 0.35rem;
    }
    .heatmap-grid {
      border-collapse: collapse;
      width: 100%;
      font-size: 0.7rem;
    }
    .heatmap-grid th,
    .heatmap-grid td {
      border: 1px solid var(--border);
      padding: 0.15rem 0.25rem;
      text-align: center;
    }
    .heatmap-grid th {
      background: var(--table-stripe);
    }
    .heatmap-cell-value {
      opacity: 0.9;
    }
	.heatmap-grid td.heatmap-failed {
	  border: 1px solid rgba(0,0,0,0.2);
	}

	[data-theme="dark"] .heatmap-grid td.heatmap-failed {
	  border-color: rgba(255,255,255,0.25);
	}

	.heatmap-grid td.heatmap-skipped {
	  opacity: 0.6;
	}


    canvas {
      width: 100%;
      max-width: 100%;
    }

    #timelineWrapper {
      margin-bottom: 1rem;
    }
    #timelineWrapper canvas {
      width: 100%;
      max-width: 100%;
    }

    details.raw-json summary {
      cursor: pointer;
      font-size: 0.85rem;
      color: var(--muted);
      margin-bottom: 0.3rem;
    }

    @media (max-width: 768px) {
      header {
        flex-direction: column;
        align-items: flex-start;
      }
      .card {
        padding: 0.9rem 0.8rem;
      }
    }

    /* Form controls (match index.html style) */
    input[type="text"],
    input[type="number"],
    select,
    textarea {
      width: 100%;
      padding: 0.4rem 0.5rem;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: color-mix(in srgb, var(--bg) 85%, var(--card) 15%);
      color: var(--fg);
      font-size: 0.85rem;
      box-sizing: border-box;
    }

    textarea {
      resize: vertical;
    }

    /* Specifically make the notes area larger by default */
    #notesTextarea {
      min-height: 120px;
    }

    /* Focus state */
    input:focus,
    select:focus,
    textarea:focus {
      outline: 1px solid var(--accent);
      border-color: var(--accent);
    }
  </style>
</head>
<body>
  <div class="page">
    <header>
      <div>
        <h1>Benchmark run details</h1>
        <div class="sub">
          Run ID: <span class="mono" id="runIdLabel">–</span>
        </div>
      </div>
      <div class="row" style="justify-content:flex-end;margin-bottom:0;">
        <a href="index.html" class="btn secondary shrink">← Back to benchmarks</a>
        <button class="btn secondary shrink" id="themeToggle">Toggle theme</button>
      </div>
    </header>

    <!-- Overview -->
    <section class="card">
      <div class="card-title">
        <h2>Overview</h2>
        <span class="pill" id="statusPill">Loading…</span>
      </div>
      <div id="overviewBody" class="muted" style="font-size:0.9rem;margin-bottom:0.5rem;">
        Fetching run data…
      </div>
      <div class="row" style="margin-top:0.25rem;flex-wrap:wrap;gap:0.5rem;">
        <div style="flex:1;min-width:180px;">
          <div id="bestHashrateChip" class="muted" style="font-size:0.8rem;"></div>
        </div>
        <div style="flex:1;min-width:180px;">
          <div id="bestEfficiencyChip" class="muted" style="font-size:0.8rem;"></div>
        </div>
        <div class="shrink" style="text-align:right;">
          <a id="csvLink" class="btn secondary shrink" href="#">Download CSV</a>
        </div>
      </div>
    </section>

    <!-- Notes -->
    <section class="card">
      <div class="card-title">
        <h2>Run notes</h2>
        <span class="pill">Add comments like “after repaste”, “stock fan”, etc.</span>
      </div>
      <textarea id="notesTextarea" placeholder="No notes yet. Add context about this run…"></textarea>
      <div class="row" style="justify-content:flex-end;margin-top:0.5rem;">
        <button class="btn shrink" id="saveNotesBtn" style="flex:0 0 auto;">Save notes</button>
      </div>
      <div id="notesStatus" class="muted" style="font-size:0.8rem;margin-top:0.35rem;"></div>
    </section>

    <!-- Results table -->
    <section class="card">
      <div class="card-title">
        <h2>Results table</h2>
        <span class="pill">Best GH/s (orange) • Best J/TH (green)</span>
      </div>
      <div id="tableContainer" style="overflow-x:auto;font-size:0.85rem;">
        <div class="muted">Loading results…</div>
      </div>
    </section>

    <!-- Charts -->
    <section class="card">
      <div class="card-title">
        <h2>Charts</h2>
        <span class="pill">Frequency, power, hashrate, efficiency, fan %, error %</span>
      </div>

      <div id="chartsEmpty" class="muted" style="font-size:0.85rem;display:none;">
        No numeric data available to plot for this run.
      </div>

      <!-- Big overall timeline chart -->
      <div id="timelineWrapper">
        <label class="muted" style="font-size:0.8rem;">Overall test (step timeline)</label>
        <canvas id="chartTimeline" height="260"></canvas>
      </div>

      <!-- Smaller per-metric charts below -->
      <div class="charts-grid" id="chartsGrid">
        <div>
          <label class="muted" style="font-size:0.8rem;">Hashrate vs frequency</label>
          <canvas id="chartHashVsFreq" height="180"></canvas>
        </div>
        <div>
          <label class="muted" style="font-size:0.8rem;">Power vs frequency</label>
          <canvas id="chartPowerVsFreq" height="180"></canvas>
        </div>
        <div>
          <label class="muted" style="font-size:0.8rem;">Efficiency vs frequency</label>
          <canvas id="chartEffVsFreq" height="180"></canvas>
        </div>
      </div>
    </section>
	
	<!-- Heatmaps (grid sweeps only) -->
    <section class="card" id="heatmapSection" style="display:none;">
      <div class="card-title">
        <h2>Voltage / frequency heatmaps</h2>
        <span class="pill">Grid sweeps only</span>
      </div>

      <div id="heatmapMeta"
           class="muted"
           style="font-size:0.8rem;margin-bottom:0.5rem;">
      </div>

      <div class="heatmaps-grid">
        <div class="heatmap-card">
          <h3>Hashrate (GH/s)</h3>
          <div id="heatmapHashContainer"></div>
        </div>
        <div class="heatmap-card">
          <h3>Efficiency (J/TH)</h3>
          <div id="heatmapEffContainer"></div>
        </div>
        <div class="heatmap-card">
          <h3>Error rate (%)</h3>
          <div id="heatmapErrContainer"></div>
        </div>
      </div>

      <div class="muted" style="font-size:0.72rem;margin-top:0.4rem;">
        Rows are core voltage (mV), columns are frequency (MHz).
        Colors go from red (worst) to green (best).
        Empty cells mean that particular combo wasn’t measured or failed early.
      </div>
    </section>

    <!-- Raw JSON (optional) -->
    <section class="card">
      <details class="raw-json">
        <summary>Show raw JSON results (for debugging)</summary>
        <pre id="rawJsonPre" class="mono" style="font-size:0.72rem;max-height:260px;overflow:auto;margin-top:0.4rem;"></pre>
      </details>
    </section>
  </div>

  <!-- Chart.js from CDN -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script>
    const root = document.documentElement;
    const apiBase = ""; // same origin

    const themeToggle = document.getElementById("themeToggle");
    const runIdLabel = document.getElementById("runIdLabel");
    const statusPill = document.getElementById("statusPill");
    const overviewBody = document.getElementById("overviewBody");
    const bestHashrateChip = document.getElementById("bestHashrateChip");
    const bestEfficiencyChip = document.getElementById("bestEfficiencyChip");
    const csvLink = document.getElementById("csvLink");
    const notesTextarea = document.getElementById("notesTextarea");
    const saveNotesBtn = document.getElementById("saveNotesBtn");
    const notesStatus = document.getElementById("notesStatus");
    const tableContainer = document.getElementById("tableContainer");
    const rawJsonPre = document.getElementById("rawJsonPre");
    const chartsGrid = document.getElementById("chartsGrid");
    const chartsEmpty = document.getElementById("chartsEmpty");
    const timelineWrapper = document.getElementById("timelineWrapper");
	const heatmapSection = document.getElementById("heatmapSection");
    const heatmapMeta = document.getElementById("heatmapMeta");
    const heatmapHashContainer = document.getElementById("heatmapHashContainer");
    const heatmapEffContainer = document.getElementById("heatmapEffContainer");
    const heatmapErrContainer = document.getElementById("heatmapErrContainer");


    function setTheme(theme) {
      root.setAttribute("data-theme", theme);
      localStorage.setItem("bb_theme", theme);
    }
	
	function describeErrorReason(code) {
      if (!code) return "";
      const upper = String(code).toUpperCase();
      switch (upper) {
        case "ERROR_RATE_TOO_HIGH":
          return "ASIC error rate exceeded threshold";
        case "ZERO_HASHRATE":
          return "average hashrate was zero";
        case "NO_DATA_COLLECTED":
          return "no valid samples collected";
        default:
          return upper.replace(/_/g, " ").toLowerCase();
      }
    }

    themeToggle.addEventListener("click", () => {
      const next = root.getAttribute("data-theme") === "dark" ? "light" : "dark";
      setTheme(next);
    });
    setTheme(localStorage.getItem("bb_theme") || "dark");

    function getRunIdFromQuery() {
      const params = new URLSearchParams(window.location.search);
      return params.get("run");
    }

    function fmtNumber(value, digits) {
      if (value === null || value === undefined) return "–";
      const n = Number(value);
      if (!isFinite(n)) return "–";
      return n.toFixed(digits);
    }

    function toNumOrNull(value) {
      if (value === null || value === undefined) return null;
      const n = Number(value);
      return isFinite(n) ? n : null;
    }

    function extractPoints(resultsRoot) {
      if (!resultsRoot) return [];
      if (Array.isArray(resultsRoot.points)) return resultsRoot.points;
      if (Array.isArray(resultsRoot.allPoints)) return resultsRoot.allPoints;
      if (Array.isArray(resultsRoot.results)) return resultsRoot.results;
      if (Array.isArray(resultsRoot.data)) return resultsRoot.data;
      return [];
    }

    function findBestIndices(points) {
      let bestHashIndex = -1;
      let bestHashValue = -Infinity;
      let bestEffIndex = -1;
      let bestEffValue = Infinity;

      points.forEach((p, idx) => {
        const hr = toNumOrNull(p.averageHashRate ?? p.hashRate ?? p.average_hashrate);
        if (hr !== null && hr > bestHashValue) {
          bestHashValue = hr;
          bestHashIndex = idx;
        }

        const eff = toNumOrNull(p.efficiencyJTH ?? p.efficiency ?? p.j_per_th);
        if (eff !== null && eff < bestEffValue) {
          bestEffValue = eff;
          bestEffIndex = idx;
        }
      });

      if (!isFinite(bestHashValue)) bestHashIndex = -1;
      if (!isFinite(bestEffValue)) bestEffIndex = -1;

      return { bestHashIndex, bestEffIndex, bestHashValue, bestEffValue };
    }
	
	function buildHeatmaps(points, resultsRoot, run) {
	  if (!heatmapSection) return;

	  let cfg = run.config || {};
	  // Prefer config from the results JSON (always an object).
	  if (resultsRoot && typeof resultsRoot.config === "object") {
		cfg = resultsRoot.config;
	  } else if (run && typeof run.config === "object") {
		// Fallback to parsed config from /api (live runs or parsed config_json)
		cfg = run.config;
	  }
	  const mode = (cfg.sweep_mode || cfg.sweepMode || "").toLowerCase();

	  if (mode !== "grid") {
		heatmapSection.style.display = "none";
		return;
	  }

	  const validPoints = points.filter((p) => {
		const v = p.coreVoltage ?? p.vcore ?? p.core_voltage;
		const f = p.frequency ?? p.freq ?? p.frequency_mhz;
		return v != null && f != null;
	  });

	  if (!validPoints.length) {
		heatmapSection.style.display = "none";
		return;
	  }

	  const voltages = Array.from(
		new Set(validPoints.map((p) => Number(p.coreVoltage ?? p.vcore ?? p.core_voltage)))
	  ).sort((a, b) => a - b);

	  const freqs = Array.from(
		new Set(validPoints.map((p) => Number(p.frequency ?? p.freq ?? p.frequency_mhz)))
	  ).sort((a, b) => a - b);

	  if (!voltages.length || !freqs.length) {
		heatmapSection.style.display = "none";
		return;
	  }

	  heatmapSection.style.display = "block";
	  heatmapMeta.textContent =
		`Grid size: ${voltages.length} voltages × ${freqs.length} frequencies (${validPoints.length} points).`;

	  // NEW: track per-voltage metadata
	  const rowMeta = {};

	  const lookup = {};
	  validPoints.forEach((p) => {
		const v = Number(p.coreVoltage ?? p.vcore ?? p.core_voltage);
		const f = Number(p.frequency ?? p.freq ?? p.frequency_mhz);
		const key = `${v}|${f}`;
		const errorReason = p.errorReason || p.error_reason || null;

		lookup[key] = {
		  hashrate: toNumOrNull(p.averageHashRate ?? p.hashRate ?? p.average_hashrate),
		  eff:      toNumOrNull(p.efficiencyJTH ?? p.efficiency ?? p.j_per_th),
		  err:      toNumOrNull(p.errorPercentage ?? p.error_pct ?? p.errorRate),
		  errorReason,
		};

		if (!rowMeta[v]) {
		  rowMeta[v] = { maxFreq: f, hadFailure: false };
		} else if (f > rowMeta[v].maxFreq) {
		  rowMeta[v].maxFreq = f;
		}
		if (errorReason) {
		  rowMeta[v].hadFailure = true;
		}
	  });

	  buildSingleHeatmap(heatmapHashContainer, voltages, freqs, lookup, "hashrate", {
		label: "GH/s",
		invert: false,
		decimals: 1,
	  }, rowMeta);

	  buildSingleHeatmap(heatmapEffContainer, voltages, freqs, lookup, "eff", {
		label: "J/TH",
		invert: true,
		decimals: 2,
	  }, rowMeta);

	  buildSingleHeatmap(heatmapErrContainer, voltages, freqs, lookup, "err", {
		label: "%",
		invert: true,
		decimals: 2,
	  }, rowMeta);
	}

    function buildSingleHeatmap(container, voltages, freqs, lookup, key, opts, rowMeta) {
	  const values = [];

	  voltages.forEach((v) => {
		freqs.forEach((f) => {
		  const entry = lookup[`${v}|${f}`];
		  if (entry && entry[key] != null && isFinite(entry[key])) {
			values.push(entry[key]);
		  }
		});
	  });

	  if (!values.length) {
		container.innerHTML =
		  `<div class="muted" style="font-size:0.75rem;">No ${opts.label} data for this grid.</div>`;
		return;
	  }

	  const min = Math.min(...values);
	  const max = Math.max(...values);
	  const span = max - min || 1;

	  function colorFor(value) {
		if (value == null || !isFinite(value)) return "transparent";
		let t = (value - min) / span;
		if (opts.invert) t = 1 - t;
		t = Math.max(0, Math.min(1, t));
		const hue = 120 * t; // 0 = red, 120 = green
		return `hsl(${hue}, 70%, 45%)`;
	  }

	  // Columns = voltages (x axis), low → high
  	  // Rows = frequencies (y axis), high → low (so low is at the bottom)
	  let html = '<table class="heatmap-grid"><thead><tr><th>MHz / mV</th>';
	  voltages.forEach((v) => {
	    html += `<th>${v}</th>`;
	  });
	  html += "</tr></thead><tbody>";

	  // Render rows from highest freq at the top to lowest at the bottom
	  const freqRows = [...freqs].sort((a, b) => b - a);

	  freqRows.forEach((f) => {
	    html += `<tr><th>${f}</th>`;

	    voltages.forEach((v) => {
	  	  const meta = rowMeta?.[v];
		  const entry = lookup[`${v}|${f}`];
		  const baseVal = entry ? entry[key] : null;

		  let bg;
		  let text = "";
		  let extraClass = "";

		  if (entry && entry.errorReason) {
		    // Explicit failure at this grid point → solid red
		    bg = "hsl(0, 80%, 40%)";
		    extraClass = "heatmap-failed";
		    text = "";
		  } else if (!entry && meta && meta.hadFailure && f > meta.maxFreq) {
		    // We stopped the sweep at a lower freq for this voltage → skipped
		    bg = "rgba(148, 163, 184, 0.4)";
		    extraClass = "heatmap-skipped";
		  } else {
		    bg = colorFor(baseVal);
		    text =
		  	  baseVal == null || !isFinite(baseVal)
			    ? ""
			    : fmtNumber(baseVal, opts.decimals);
		  }

		  html += `<td class="${extraClass}" style="background:${bg};"><span class="heatmap-cell-value">${text}</span></td>`;
	    });

	    html += "</tr>";
	  });

	html += "</tbody></table>";
	container.innerHTML = html;


	  html += "</tbody></table>";
	  container.innerHTML = html;
	}

    function renderTable(points) {
      if (!points.length) {
        tableContainer.innerHTML = `<div class="muted">No results recorded for this run.</div>`;
        return;
      }

      const { bestHashIndex, bestEffIndex } = findBestIndices(points);

      const rowsHtml = points.map((p, idx) => {
        const step = p.step ?? p.index ?? (idx + 1);
        const v = p.coreVoltage ?? p.vcore ?? p.core_voltage;
        const f = p.frequency ?? p.freq ?? p.frequency_mhz;
        const hr = p.averageHashRate ?? p.hashRate ?? p.average_hashrate;
        const pow = p.averagePower ?? p.power ?? p.power_watts;
        const eff = p.efficiencyJTH ?? p.efficiency ?? p.j_per_th;
        const t = p.averageTemperature ?? p.temp ?? p.temperature;
        const vrT = p.averageVRTemp ?? p.vrTemp ?? p.vr_temperature;
        const fanPct = p.fanSpeed ?? p.fan_pct ?? p.fanspeed;
        const fanRpm = p.fanRPM ?? p.fan_rpm ?? p.fanrpm;
        const errPct = p.errorPct ?? p.error_percentage ?? p.errorPercentage ?? p.error_percent;

        const hrClass = idx === bestHashIndex ? "best-hashrate" : "";
        const effClass = idx === bestEffIndex ? "best-efficiency" : "";

        return `
          <tr>
            <td class="mono">${step}</td>
            <td class="mono">${fmtNumber(v, 0)}</td>
            <td class="mono">${fmtNumber(f, 0)}</td>
            <td class="mono ${hrClass}">${fmtNumber(hr, 1)}</td>
            <td class="mono">${fmtNumber(pow, 2)}</td>
            <td class="mono ${effClass}">${fmtNumber(eff, 2)}</td>
            <td class="mono">${errPct === null || errPct === undefined ? "–" : fmtNumber(errPct, 2)}</td>
            <td class="mono">${fmtNumber(t, 1)}</td>
            <td class="mono">${fmtNumber(vrT, 1)}</td>
            <td class="mono">${fanPct === null || fanPct === undefined ? "–" : fmtNumber(fanPct, 0)}</td>
            <td class="mono">${fanRpm === null || fanRpm === undefined ? "–" : fmtNumber(fanRpm, 0)}</td>
          </tr>
        `;
      }).join("");

      tableContainer.innerHTML = `
        <table>
          <thead>
            <tr>
              <th>#</th>
              <th>Core mV</th>
              <th>MHz</th>
              <th>GH/s</th>
              <th>Power (W)</th>
              <th>J/TH</th>
              <th>Error %</th>
              <th>°C</th>
              <th>VR °C</th>
              <th>Fan %</th>
              <th>Fan RPM</th>
            </tr>
          </thead>
          <tbody>
            ${rowsHtml}
          </tbody>
        </table>
      `;
    }

    function renderOverview(run, resultsRoot, points) {
      runIdLabel.textContent = run.id || "unknown";

      const status = (run.status || "").toLowerCase();
      statusPill.textContent = run.status || "unknown";

      const started = (run.started_at || "").split(".")[0] || "–";
      const finished = (run.finished_at || "").split(".")[0] || "–";
      const device = run.device_type || run.deviceType || "unknown device";
      const ip = run.bitaxe_ip || "–";
      const profile = run.profile_name || run.profile || "–";
      const totalPoints = points.length || "0";
	  
	  // NEW: derive a friendly failure reason
      const rawErr = (run.error_reason || run.errorReason || "");
      const errorReason = rawErr ? String(rawErr).toUpperCase() : "";
      const threshold = toNumOrNull(
        run.config?.error_rate_warn_threshold ??
        run.config?.errorRateWarnThreshold
      );
      let failureReasonLine = "";
      if (status === "failed" || errorReason) {
        let msg;
        if (errorReason === "ERROR_RATE_TOO_HIGH") {
          const suffix =
            threshold != null ? ` (threshold ${threshold.toFixed(2)}%)` : "";
          msg = `failed because ASIC error rate exceeded the configured threshold${suffix}.`;
        } else if (errorReason === "ZERO_HASHRATE") {
          msg = "failed because average hashrate was zero.";
        } else if (errorReason) {
          msg = `failed due to ${describeErrorReason(errorReason)}.`;
        } else if (status === "failed") {
          msg = "failed because hashrate stayed below the expected target.";
        }
        if (msg) {
          failureReasonLine = `<br/>Failure reason: <span class="mono">${msg}</span>`;
        }
      }

      overviewBody.innerHTML = `
        <div style="margin-bottom:0.35rem;">
          <strong>${device}</strong> @ <span class="mono">${ip}</span>
        </div>
        <div style="font-size:0.85rem;">
          Status: <span class="mono">${run.status || "unknown"}</span><br/>
          Profile: <span class="mono">${profile}</span><br/>
          Started: <span class="mono">${started}</span><br/>
          Finished: <span class="mono">${finished}</span><br/>
          Steps completed: <span class="mono">${totalPoints}</span>
		  ${failureReasonLine}
        </div>
      `;

      // Best points from summarized data if available, otherwise derive
      let bestHashPoint = null;
      let bestEffPoint = null;

      if (Array.isArray(resultsRoot?.topPerformers) && resultsRoot.topPerformers.length) {
        bestHashPoint = resultsRoot.topPerformers[0];
      }

      if (Array.isArray(resultsRoot?.mostEfficient) && resultsRoot.mostEfficient.length) {
        bestEffPoint = resultsRoot.mostEfficient[0];
      }

      const { bestHashIndex, bestEffIndex, bestHashValue, bestEffValue } = findBestIndices(points);

      if (!bestHashPoint && bestHashIndex >= 0) {
        bestHashPoint = points[bestHashIndex];
      }
      if (!bestEffPoint && bestEffIndex >= 0) {
        bestEffPoint = points[bestEffIndex];
      }

      if (bestHashPoint) {
        const hr = fmtNumber(bestHashPoint.averageHashRate ?? bestHashPoint.hashRate, 1);
        const v = bestHashPoint.coreVoltage ?? bestHashPoint.vcore;
        const f = bestHashPoint.frequency ?? bestHashPoint.freq;
        bestHashrateChip.innerHTML =
          `Best hashrate: <strong>${hr} GH/s</strong> @ ` +
          `<span class="mono">${fmtNumber(v,0)} mV</span> / ` +
          `<span class="mono">${fmtNumber(f,0)} MHz</span>`;
      } else if (isFinite(bestHashValue)) {
        bestHashrateChip.textContent = `Best hashrate: ${fmtNumber(bestHashValue,1)} GH/s`;
      } else {
        bestHashrateChip.textContent = "Best hashrate: –";
      }

      if (bestEffPoint) {
        const eff = fmtNumber(bestEffPoint.efficiencyJTH ?? bestEffPoint.efficiency, 2);
        const v = bestEffPoint.coreVoltage ?? bestEffPoint.vcore;
        const f = bestEffPoint.frequency ?? bestEffPoint.freq;
        bestEfficiencyChip.innerHTML =
          `Best efficiency: <strong>${eff} J/TH</strong> @ ` +
          `<span class="mono">${fmtNumber(v,0)} mV</span> / ` +
          `<span class="mono">${fmtNumber(f,0)} MHz</span>`;
      } else if (isFinite(bestEffValue)) {
        bestEfficiencyChip.textContent = `Best efficiency: ${fmtNumber(bestEffValue,2)} J/TH`;
      } else {
        bestEfficiencyChip.textContent = "Best efficiency: –";
      }
    }

    function buildCharts(points) {
      if (!points.length || typeof Chart === "undefined") {
        chartsGrid.style.display = "none";
        chartsEmpty.style.display = "block";
        if (timelineWrapper) timelineWrapper.style.display = "none";
        return;
      }

      chartsGrid.style.display = "grid";
      chartsEmpty.style.display = "none";
      if (timelineWrapper) timelineWrapper.style.display = "block";

      const labelsFreq = points.map((p) => p.frequency ?? p.freq ?? p.frequency_mhz ?? null);
      const labelsSteps = points.map((p, idx) => p.step ?? p.index ?? (idx + 1));

      const hrData = points.map((p) => toNumOrNull(p.averageHashRate ?? p.hashRate ?? p.average_hashrate));
      const powData = points.map((p) => toNumOrNull(p.averagePower ?? p.power ?? p.power_watts));
      const effData = points.map((p) => toNumOrNull(p.efficiencyJTH ?? p.efficiency ?? p.j_per_th));
      const freqData = points.map((p) => toNumOrNull(p.frequency ?? p.freq ?? p.frequency_mhz));
      const vcoreData = points.map((p) => toNumOrNull(p.coreVoltage ?? p.vcore ?? p.core_voltage));
      const fanPctData = points.map((p) =>
        toNumOrNull(p.fanSpeed ?? p.fan_pct ?? p.fanspeed)
      );
      const errPctData = points.map((p) =>
        toNumOrNull(p.errorPct ?? p.error_percentage ?? p.errorPercentage ?? p.error_percent)
      );

      const ctxHashVsFreq = document.getElementById("chartHashVsFreq").getContext("2d");
      const ctxPowerVsFreq = document.getElementById("chartPowerVsFreq").getContext("2d");
      const ctxEffVsFreq = document.getElementById("chartEffVsFreq").getContext("2d");
      const ctxTimeline = document.getElementById("chartTimeline").getContext("2d");

      new Chart(ctxHashVsFreq, {
        type: "line",
        data: {
          labels: labelsFreq,
          datasets: [
            {
              label: "Hashrate (GH/s)",
              data: hrData,
              spanGaps: true
            }
          ]
        },
        options: {
          responsive: true,
          plugins: {
            legend: { display: true }
          },
          scales: {
            x: {
              title: { display: true, text: "Frequency (MHz)" }
            },
            y: {
              title: { display: true, text: "GH/s" }
            }
          }
        }
      });

      new Chart(ctxPowerVsFreq, {
        type: "line",
        data: {
          labels: labelsFreq,
          datasets: [
            {
              label: "Power (W)",
              data: powData,
              spanGaps: true
            }
          ]
        },
        options: {
          responsive: true,
          plugins: {
            legend: { display: true }
          },
          scales: {
            x: {
              title: { display: true, text: "Frequency (MHz)" }
            },
            y: {
              title: { display: true, text: "Power (W)" }
            }
          }
        }
      });

      new Chart(ctxEffVsFreq, {
        type: "line",
        data: {
          labels: labelsFreq,
          datasets: [
            {
              label: "Efficiency (J/TH)",
              data: effData,
              spanGaps: true
            }
          ]
        },
        options: {
          responsive: true,
          plugins: {
            legend: { display: true }
          },
          scales: {
            x: {
              title: { display: true, text: "Frequency (MHz)" }
            },
            y: {
              title: { display: true, text: "J/TH" }
            }
          }
        }
      });

      new Chart(ctxTimeline, {
        type: "line",
        data: {
          labels: labelsSteps,
          datasets: [
            {
              label: "Frequency (MHz)",
              data: freqData,
              spanGaps: true,
              yAxisID: "yFreq"
            },
            {
              label: "Core mV",
              data: vcoreData,
              spanGaps: true,
              yAxisID: "yFreq"
            },
            {
              label: "Power (W)",
              data: powData,
              spanGaps: true,
              yAxisID: "yPower"
            },
            {
              label: "Hashrate (GH/s)",
              data: hrData,
              spanGaps: true,
              yAxisID: "yHash"
            },
            {
              label: "Efficiency (J/TH)",
              data: effData,
              spanGaps: true,
              yAxisID: "yEff"
            },
            {
              label: "Fan %",
              data: fanPctData,
              spanGaps: true,
              yAxisID: "yAux"
            },
            {
              label: "Error %",
              data: errPctData,
              spanGaps: true,
              yAxisID: "yAux"
            }
          ]
        },
        options: {
          responsive: true,
          plugins: {
            legend: { display: true }
          },
          scales: {
            x: {
              title: { display: true, text: "Step #" }
            },
            yHash: {
              type: "linear",
              position: "left",
              title: { display: true, text: "GH/s" }
            },
            yPower: {
              type: "linear",
              position: "right",
              title: { display: true, text: "Power (W)" },
              grid: { drawOnChartArea: false }
            },
            yFreq: {
              type: "linear",
              position: "right",
              title: { display: true, text: "Freq / Core mV" },
              grid: { drawOnChartArea: false },
              offset: true
            },
            yEff: {
              type: "linear",
              position: "left",
              title: { display: true, text: "J/TH" },
              grid: { drawOnChartArea: false }
            },
            yAux: {
              type: "linear",
              position: "right",
              title: { display: true, text: "Fan % / Error %" },
              grid: { drawOnChartArea: false }
            }
          }
        }
      });
    }

    async function saveNotes(runId, notes) {
      saveNotesBtn.disabled = true;
      saveNotesBtn.textContent = "Saving…";
      notesStatus.textContent = "";
      try {
        const res = await fetch(`${apiBase}/api/benchmarks/${encodeURIComponent(runId)}/notes`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ notes })
        });
        if (!res.ok) {
          let msg = "Failed to save notes.";
          try {
            const text = await res.text();
            if (text) msg = text;
          } catch (_) {}
          throw new Error(msg);
        }
        notesStatus.textContent = "Notes saved.";
      } catch (err) {
        console.error(err);
        notesStatus.textContent = err.message || "Failed to save notes.";
      } finally {
        saveNotesBtn.disabled = false;
        saveNotesBtn.textContent = "Save notes";
      }
    }

    (async () => {
      const runId = getRunIdFromQuery();
      if (!runId) {
        overviewBody.innerHTML = `<span class="muted">No run id specified in URL.</span>`;
        chartsGrid.style.display = "none";
        chartsEmpty.style.display = "block";
        tableContainer.innerHTML = `<div class="muted">No run selected.</div>`;
        return;
      }

      runIdLabel.textContent = runId;
      csvLink.href = `${apiBase}/api/benchmarks/${encodeURIComponent(runId)}/csv`;

      try {
        const res = await fetch(`${apiBase}/api/benchmarks/${encodeURIComponent(runId)}?include_results=true`);
        if (!res.ok) {
          let msg = "Failed to load run.";
          try {
            const txt = await res.text();
            if (txt) msg = txt;
          } catch (_) {}
          throw new Error(msg);
        }
        const run = await res.json();

        const resultsRoot = run.resultsFile || run;
        const points = extractPoints(resultsRoot);

        renderOverview(run, resultsRoot, points);
        renderTable(points);
        buildCharts(points);
		buildHeatmaps(points, resultsRoot, run);

        notesTextarea.value = run.notes || "";
        rawJsonPre.textContent = JSON.stringify(resultsRoot, null, 2);

        saveNotesBtn.addEventListener("click", () => {
          const notes = notesTextarea.value;
          saveNotes(run.id || runId, notes);
        });
      } catch (err) {
        console.error(err);
        overviewBody.innerHTML = `<span class="muted">${err.message || "Failed to load run data."}</span>`;
        tableContainer.innerHTML = `<div class="muted">Unable to render table.</div>`;
        chartsGrid.style.display = "none";
        chartsEmpty.style.display = "block";
      }
    })();
  </script>
</body>
</html>
